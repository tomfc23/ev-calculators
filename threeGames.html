<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pool EV Calculator - 3 Matchups</title>
  <style>
   * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: sans-serif;
  line-height: 1.6;
  background-color: black;
  color: lightgray;
  text-align: center;
}

.container {
  max-width: 72rem;
  margin: 0 auto;
  padding: 1rem;
}

.heading {
  font-size: 1.875rem;
  font-weight: 700;
  margin-bottom: 1.5rem;
  text-align: center;
}

.subheading {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
}

.section-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.instructions {
  background-color: #333;
  padding: 1rem;
  border-radius: 25px;
  margin-bottom: 1.5rem;
  border: 2px solid #555;
}

.instructions p {
  margin-bottom: 0.5rem;
}

.form-control {
  margin-bottom: 1.5rem;
}

.form-label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: lightgray;
  margin-bottom: 0.25rem;
}

.form-input {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 15px;
  width: 100%;
  font-size: 16px;
  background-color: #333;
  color: lightgray;
  transition: border-color 0.3s;
}

.form-input:focus {
  border-color: #007BFF;
  outline: none;
}

.form-select {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 15px;
  width: 100%;
  font-size: 16px;
  background-color: #333;
  color: lightgray;
  transition: border-color 0.3s;
}

.form-select:focus {
  border-color: #007BFF;
  outline: none;
}

.games-grid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.card {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 1rem;
  background-color: #222;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.game-card {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 1rem;
  background-color: #222;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.teams-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}

.team-card {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 0.75rem;
  background-color: #333;
}

.push-inputs {
  margin-top: 1rem;
  padding: 1rem;
  background-color: #2a2a2a;
  border-radius: 15px;
  border: 1px solid #555;
}

.push-display {
  text-align: center;
  font-weight: 600;
  color: #ffa500;
  margin-top: 0.5rem;
}

.btn {
  border: none;
  border-radius: 25px;
  padding: 15px;
  cursor: pointer;
  font-size: 16px;
  width: 100%;
  transition: background-color 0.3s;
}

.btn-default {
  background-color: #444;
  color: white;
}

.btn-primary {
  background-color: #6f42c1;
  color: white;
}

.btn-primary:hover {
  background-color: #5a32a3;
}

.calculate-btn {
  background-color: #6f42c1;
  color: white;
  padding: 15px;
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  border-radius: 25px;
}

.calculate-btn:hover {
  background-color: #5a32a3;
}

.results-grid {
  display: grid;
  grid-template-columns: repeat(1, minmax(0, 1fr));
  gap: 1.5rem;
}

.info-box {
  background-color: #333;
  padding: 1rem;
  border-radius: 25px;
  margin-bottom: 1rem;
  border: 2px solid #555;
}

.table-container {
  background-color: #333;
  padding: 1rem;
  border-radius: 25px;
  max-height: 30rem;
  overflow-y: auto;
  border: 2px solid #555;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
  color: lightgray;
}

th {
  text-align: left;
  padding: 0.5rem;
  border-bottom: 1px solid #555;
  position: sticky;
  top: 0;
  background-color: #222;
  color: lightgray;
}

td {
  padding: 0.5rem;
}

tr:nth-child(even) {
  background-color: #2a2a2a;
}

.explanation {
  border: 2px solid #555;
  border-radius: 25px;
  padding: 1.5rem;
  background-color: #222;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  margin-top: 2rem;
}

.code-block {
  background-color: #333;
  padding: 0.5rem;
  border-radius: 15px;
  overflow-x: auto;
  font-size: 0.875rem;
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
  word-wrap: break-word;
  color: #ddd;
  border: 1px solid #555;
}

.text-note {
  font-size: 0.75rem;
  color: #aaa;
  margin-top: 0.5rem;
}

.sort-button {
  background: none;
  border: none;
  cursor: pointer;
  font-weight: bold;
  color: #858bf0;
  margin-left: 0.25rem;
}

a {
  color: #858bf0;
}

@media (min-width: 768px) {
  .games-grid, .results-grid {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}
  </style>
</head>
<body>
  <div class="container" id="app">
    <h1 class="heading">Pool EV Calculator - 3 Matchups</h1>
    <div class="instructions">
      <h2 class="section-title">Instructions</h2>
      <p>1. Enter the details for each of the 3 games including odds (American format), and selection percentages.</p>
      <p>2. For each game, select .5 Spread (no push) or .0 Spread (push possible).</p>
      <p>3. For .0 spreads, enter the win probabilities for the adjusted lines (e.g., -7.5 and +8.5 for a -8.0 spread).</p>
      <p>4. Click "Calculate" to see all combinations with their expected values, probabilities, and potential payouts.</p>
      <p>5. Total pool entrants is set to 9,450. Payouts are only awarded for correctly predicting all 3 matchups.</p>
      <p>6. Payout formula: Min((Total entrants * 100) / Number of winners, 600) - Maximum payout is capped at 600.</p>
      <p>7. <strong>Push Logic:</strong> When a push occurs, BOTH sides are awarded a win for that leg (increases winner counts and lowers payouts).</p>
    </div>
    
    <form id="calculator-form">
      <div class="games-grid" id="games-container">
        <!-- Games will be dynamically added here -->
      </div>
      
      <button type="button" class="btn calculate-btn" id="calculate-btn">Calculate Results</button>
    </form>
    
    <div id="results-container" style="display: none;">
      <!-- Results will be dynamically added here -->
    </div>
    <button class="btn btn-primary" id="copy-results-btn" style="margin-top: 1rem;">Copy Results</button>
  </div>

  <script>
document.addEventListener('DOMContentLoaded', () => {
  class PoolCalculator {
    constructor() {
      this.state = {
        games: [
          { 
            id: 1, 
            spreadType: '0.5',
            team1: { name: 'L1', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 }, 
            team2: { name: 'R1', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 },
            pushProbability: 0
          },
          { 
            id: 2, 
            spreadType: '0.5',
            team1: { name: 'L2', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 }, 
            team2: { name: 'R2', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 },
            pushProbability: 0
          },
          { 
            id: 3, 
            spreadType: '0.5',
            team1: { name: 'L3', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 }, 
            team2: { name: 'R3', odds: -110, selectionPercentage: 50, noVigOdds: -100, noVigProbability: 0.5, pushOdds: -110 },
            pushProbability: 0
          }
        ],
        totalEntrants: 9450,
        maxPayout: 600,
        results: {
          combinations: [],
          payouts: {}
        },
        sortBy: 'expectedValue',
        sortDirection: 'desc'
      };

      this.bindEvents();
      this.renderGames();
      this.calculateNoVigOddsForAllGames();
    }

    bindEvents() {
      document.getElementById('calculate-btn').addEventListener('click', () => {
        this.collectFormData();
        this.calculateNoVigOddsForAllGames();
        this.calculateAllCombinations();
      });

      document.getElementById('copy-results-btn').addEventListener('click', () => {
        this.copyResultsToClipboard();
      });

      window.sortTable = this.sortTable.bind(this);
    }

    autofillRightPercents(gameId, changedSide) {
      const leftInput = document.getElementById(`game-${gameId}-team1-selection`);
      const rightInput = document.getElementById(`game-${gameId}-team2-selection`);

      let val = parseFloat(changedSide === 'left' ? leftInput.value : rightInput.value) || 0;
      val = Math.min(100, Math.max(0, val));

      if (changedSide === 'left') {
        rightInput.value = (100 - val).toFixed(0);
      } else {
        leftInput.value = (100 - val).toFixed(0);
      }
    }

    togglePushInputs(gameId) {
      const game = this.state.games.find(g => g.id === gameId);
      const spreadType = document.getElementById(`game-${gameId}-spread-type`).value;
      
      game.spreadType = spreadType;
      
      const pushInputsL = document.getElementById(`game-${gameId}-push-inputs-team1`);
      const pushInputsR = document.getElementById(`game-${gameId}-push-inputs-team2`);
      const pushDisplay = document.getElementById(`game-${gameId}-push-display`);
      
      if (spreadType === '0.0') {
        pushInputsL.style.display = 'block';
        pushInputsR.style.display = 'block';
        pushDisplay.style.display = 'block';
        this.updatePushDisplay(gameId);
      } else {
        pushInputsL.style.display = 'none';
        pushInputsR.style.display = 'none';
        pushDisplay.style.display = 'none';
        game.pushProbability = 0;
      }
      this.calculateNoVigOddsForAllGames();
    }

    updatePushDisplay(gameId) {
      const game = this.state.games.find(g => g.id === gameId);
      const oddsL = parseFloat(document.getElementById(`game-${gameId}-team1-push-odds`).value) || -110;
      const oddsR = parseFloat(document.getElementById(`game-${gameId}-team2-push-odds`).value) || -110;
      
      game.team1.pushOdds = oddsL;
      game.team2.pushOdds = oddsR;
      
      // Convert American odds to implied probabilities
      const impL = this.oddsToImpliedProbability(oddsL);
      const impR = this.oddsToImpliedProbability(oddsR);
      
      // Calculate push probability as the excess probability above 1
      const totalImplied = impL + impR;
      const pushProb = Math.max(0, totalImplied - 1);
      
      // Normalize all probabilities to sum to 1
      const totalProb = impL + impR + pushProb;
      const normalizedPushProb = pushProb / totalProb;
      
      // Cap at reasonable levels after normalization
      const finalPushProb = Math.min(Math.max(normalizedPushProb, 0.01), 0.15);
      
      game.pushProbability = finalPushProb;
      
      // Update just the push probability display
      const pushProbSpan = document.getElementById(`game-${gameId}-push-prob`);
      if (pushProbSpan) {
        pushProbSpan.textContent = `${(finalPushProb * 100).toFixed(1)}%`;
      }
      
      // Update the no-vig calculations for this specific game
      const probL = impL / totalProb;
      const probR = impR / totalProb;
      
      game.team1.noVigProbability = probL;
      game.team2.noVigProbability = probR;
      game.team1.noVigOdds = Math.round(this.probabilityToAmericanOdds(probL));
      game.team2.noVigOdds = Math.round(this.probabilityToAmericanOdds(probR));
      
      // Update odds displays for just this game
      this.updateSingleGameOddsDisplay(gameId);
    }

    updateSingleGameOddsDisplay(gameId) {
      const game = this.state.games.find(g => g.id === gameId);
      const team1OddsLabel = document.querySelector(`#games-container .game-card:nth-child(${gameId}) .team-card:nth-child(1) .form-control:last-child .form-label`);
      const team1OddsNote = document.querySelector(`#games-container .game-card:nth-child(${gameId}) .team-card:nth-child(1) .form-control:last-child .text-note`);
      const team2OddsLabel = document.querySelector(`#games-container .game-card:nth-child(${gameId}) .team-card:nth-child(2) .form-control:last-child .form-label`);
      const team2OddsNote = document.querySelector(`#games-container .game-card:nth-child(${gameId}) .team-card:nth-child(2) .form-control:last-child .text-note`);

      if (team1OddsLabel && team1OddsNote && team2OddsLabel && team2OddsNote) {
        team1OddsLabel.textContent = `No-Vig Odds: ${game.team1.noVigOdds}`;
        team1OddsNote.textContent = `No-Vig Probability: ${(game.team1.noVigProbability * 100).toFixed(2)}%`;
        team2OddsLabel.textContent = `No-Vig Odds: ${game.team2.noVigOdds}`;
        team2OddsNote.textContent = `No-Vig Probability: ${(game.team2.noVigProbability * 100).toFixed(2)}%`;
      }
    }

    renderGames() {
      const container = document.getElementById('games-container');
      container.innerHTML = '';

      this.state.games.forEach(game => {
        const div = document.createElement('div');
        div.className = 'game-card';
        div.innerHTML = `
          <h3 class="section-title">Game ${game.id}</h3>
          
          <div class="form-control">
            <label class="form-label">Spread Type</label>
            <select class="form-select" id="game-${game.id}-spread-type">
              <option value="0.5">.5 Spread (No Push)</option>
              <option value="0.0">.0 Spread (Push Possible)</option>
            </select>
          </div>
          
          <div class="teams-grid">
            <div class="team-card">
              <div class="form-control"><label class="form-label">${game.team1.name}</label></div>
              <div class="form-control"><label class="form-label">American Odds</label>
                <input type="number" class="form-input" id="game-${game.id}-team1-odds" value="${game.team1.odds}" />
              </div>
              <div class="form-control"><label class="form-label">Selection %</label>
                <input type="number" class="form-input" id="game-${game.id}-team1-selection" value="${game.team1.selectionPercentage}" min="0" max="100"
                oninput="app.autofillRightPercents(${game.id}, 'left')" />
              </div>
              <div class="push-inputs" id="game-${game.id}-push-inputs-team1" style="display: none;">
                <div class="form-control">
                  <label class="form-label">American Odds (e.g., -115 for -7.5)</label>
                  <input type="number" class="form-input" id="game-${game.id}-team1-push-odds" value="${game.team1.pushOdds}" />
                </div>
              </div>
              <div class="form-control">
                <label class="form-label">No-Vig Odds: ${game.team1.noVigOdds}</label>
                <div class="text-note">No-Vig Probability: ${(game.team1.noVigProbability * 100).toFixed(2)}%</div>
              </div>
            </div>

            <div class="team-card">
              <div class="form-control"><label class="form-label">${game.team2.name}</label></div>
              <div class="form-control"><label class="form-label">American Odds</label>
                <input type="number" class="form-input" id="game-${game.id}-team2-odds" value="${game.team2.odds}" />
              </div>
              <div class="form-control"><label class="form-label">Selection %</label>
                <input type="number" class="form-input" id="game-${game.id}-team2-selection" value="${game.team2.selectionPercentage}" min="0" max="100"
                oninput="app.autofillRightPercents(${game.id}, 'right')" />
              </div>
              <div class="push-inputs" id="game-${game.id}-push-inputs-team2" style="display: none;">
                <div class="form-control">
                  <label class="form-label">American Odds (e.g., -105 for +8.5)</label>
                  <input type="number" class="form-input" id="game-${game.id}-team2-push-odds" value="${game.team2.pushOdds}" />
                </div>
              </div>
              <div class="form-control">
                <label class="form-label">No-Vig Odds: ${game.team2.noVigOdds}</label>
                <div class="text-note">No-Vig Probability: ${(game.team2.noVigProbability * 100).toFixed(2)}%</div>
              </div>
            </div>
          </div>
          
          <div class="push-display" id="game-${game.id}-push-display" style="display: none;">
            Push Probability: <span id="game-${game.id}-push-prob">0.0%</span>
          </div>
        `;
        container.appendChild(div);

        // Add event listeners after adding to DOM
        const spreadSelect = document.getElementById(`game-${game.id}-spread-type`);
        spreadSelect.value = game.spreadType;
        spreadSelect.addEventListener('change', () => this.togglePushInputs(game.id));

        const pushOddsL = document.getElementById(`game-${game.id}-team1-push-odds`);
        const pushOddsR = document.getElementById(`game-${game.id}-team2-push-odds`);
        pushOddsL.addEventListener('input', () => this.updatePushDisplay(game.id));
        pushOddsR.addEventListener('input', () => this.updatePushDisplay(game.id));

        // Initialize push inputs visibility
        if (game.spreadType === '0.0') {
          this.togglePushInputs(game.id);
        }
      });
    }

    collectFormData() {
      this.state.games.forEach(game => {
        const t1Odds = document.getElementById(`game-${game.id}-team1-odds`);
        const t1Sel = document.getElementById(`game-${game.id}-team1-selection`);
        const t2Odds = document.getElementById(`game-${game.id}-team2-odds`);
        const t2Sel = document.getElementById(`game-${game.id}-team2-selection`);
        const spreadType = document.getElementById(`game-${game.id}-spread-type`);

        game.team1.odds = parseInt(t1Odds.value) || 0;
        game.team1.selectionPercentage = parseInt(t1Sel.value) || 0;
        game.team2.odds = parseInt(t2Odds.value) || 0;
        game.team2.selectionPercentage = parseInt(t2Sel.value) || 0;
        game.spreadType = spreadType.value;

        if (game.spreadType === '0.0') {
          const t1PushOdds = document.getElementById(`game-${game.id}-team1-push-odds`);
          const t2PushOdds = document.getElementById(`game-${game.id}-team2-push-odds`);
          game.team1.pushOdds = parseInt(t1PushOdds.value) || -110;
          game.team2.pushOdds = parseInt(t2PushOdds.value) || -110;
        }
      });
    }

    oddsToImpliedProbability(odds) {
      return odds > 0 ? 100 / (odds + 100) : Math.abs(odds) / (Math.abs(odds) + 100);
    }

    probabilityToAmericanOdds(prob) {
      if (prob <= 0 || prob >= 1) return 0;
      return prob > 0.5 ? -100 * prob / (1 - prob) : 100 * (1 - prob) / prob;
    }

    calculateNoVigOddsForAllGames() {
      this.state.games.forEach(game => {
        if (game.spreadType === '0.0') {
          // For .0 spreads, use push odds and calculate normalized probabilities
          const impL = this.oddsToImpliedProbability(game.team1.pushOdds);
          const impR = this.oddsToImpliedProbability(game.team2.pushOdds);
          
          const totalImplied = impL + impR;
          const pushProb = Math.max(0, totalImplied - 1);
          const totalProb = impL + impR + pushProb;
          
          const probL = impL / totalProb;
          const probR = impR / totalProb;
          const normalizedPushProb = pushProb / totalProb;
          
          game.team1.noVigProbability = probL;
          game.team2.noVigProbability = probR;
          game.pushProbability = Math.min(Math.max(normalizedPushProb, 0.01), 0.15);
          
          game.team1.noVigOdds = Math.round(this.probabilityToAmericanOdds(probL));
          game.team2.noVigOdds = Math.round(this.probabilityToAmericanOdds(probR));
        } else {
          // Regular .5 spread logic
          const p1 = this.oddsToImpliedProbability(game.team1.odds);
          const p2 = this.oddsToImpliedProbability(game.team2.odds);
          const total = p1 + p2;

          const fairP1 = p1 / total;
          const fairP2 = p2 / total;

          game.team1.noVigProbability = fairP1;
          game.team2.noVigProbability = fairP2;
          game.pushProbability = 0;
          game.team1.noVigOdds = Math.round(this.probabilityToAmericanOdds(fairP1));
          game.team2.noVigOdds = Math.round(this.probabilityToAmericanOdds(fairP2));
        }
      });

      this.updateOddsDisplays();
    }

    updateOddsDisplays() {
      // Update odds displays without re-rendering entire games
      this.state.games.forEach(game => {
        const team1OddsLabel = document.querySelector(`#games-container .game-card:nth-child(${game.id}) .team-card:nth-child(1) .form-control:last-child .form-label`);
        const team1OddsNote = document.querySelector(`#games-container .game-card:nth-child(${game.id}) .team-card:nth-child(1) .form-control:last-child .text-note`);
        const team2OddsLabel = document.querySelector(`#games-container .game-card:nth-child(${game.id}) .team-card:nth-child(2) .form-control:last-child .form-label`);
        const team2OddsNote = document.querySelector(`#games-container .game-card:nth-child(${game.id}) .team-card:nth-child(2) .form-control:last-child .text-note`);

        if (team1OddsLabel && team1OddsNote && team2OddsLabel && team2OddsNote) {
          team1OddsLabel.textContent = `No-Vig Odds: ${game.team1.noVigOdds}`;
          team1OddsNote.textContent = `No-Vig Probability: ${(game.team1.noVigProbability * 100).toFixed(2)}%`;
          team2OddsLabel.textContent = `No-Vig Odds: ${game.team2.noVigOdds}`;
          team2OddsNote.textContent = `No-Vig Probability: ${(game.team2.noVigProbability * 100).toFixed(2)}%`;
        }
      });
    }

    generateAllOutcomes() {
      // Generate all possible outcomes considering push possibilities
      let outcomes = [''];
      
      for (let i = 0; i < this.state.games.length; i++) {
        const game = this.state.games[i];
        const newOutcomes = [];
        
        if (game.spreadType === '0.0') {
          // .0 spread: L, R, P (push)
          outcomes.forEach(outcome => {
            newOutcomes.push(outcome + '0'); // L
            newOutcomes.push(outcome + '1'); // R  
            newOutcomes.push(outcome + 'P'); // Push
          });
        } else {
          // .5 spread: L, R only
          outcomes.forEach(outcome => {
            newOutcomes.push(outcome + '0'); // L
            newOutcomes.push(outcome + '1'); // R
          });
        }
        outcomes = newOutcomes;
      }
      
      return outcomes;
    }

    calculateMatches(userPick, outcome) {
      let matches = 0;
      for (let i = 0; i < 3; i++) {
        const userChoice = userPick[i];
        const gameOutcome = outcome[i];
        
        if (gameOutcome === 'P') {
          // Push - BOTH sides are considered correct (user gets this pick right regardless of what they picked)
          matches++;
        } else if (userChoice === gameOutcome) {
          // Exact match - user picked the correct side
          matches++;
        }
      }
      return matches;
    }

    generateCombinations() {
      let combos = [
        { teams: [this.state.games[0].team1], gameIds: [1], side: ['team1'], pickString: '0' },
        { teams: [this.state.games[0].team2], gameIds: [1], side: ['team2'], pickString: '1' }
      ];

      for (let i = 1; i < this.state.games.length; i++) {
        const game = this.state.games[i];
        const newCombos = [];

        combos.forEach(c => {
          newCombos.push({ 
            teams: [...c.teams, game.team1], 
            gameIds: [...c.gameIds, i + 1], 
            side: [...c.side, 'team1'],
            pickString: c.pickString + '0'
          });
          newCombos.push({ 
            teams: [...c.teams, game.team2], 
            gameIds: [...c.gameIds, i + 1], 
            side: [...c.side, 'team2'],
            pickString: c.pickString + '1'
          });
        });

        combos = newCombos;
      }

      return combos;
    }

    calculateSelections(combos) {
      return combos.map(combo => {
        let relative = 1;
        combo.teams.forEach((team, idx) => {
          const game = this.state.games[idx];
          const total = game.team1.selectionPercentage + game.team2.selectionPercentage || 100;
          relative *= (team.selectionPercentage / total);
        });

        return {
          ...combo,
          selectionPercentage: relative * 100,
          numberOfSelections: Math.round(this.state.totalEntrants * relative)
        };
      });
    }

    calculateWinProbabilities(combos) {
      return combos.map(combo => {
        const p = combo.teams.reduce((acc, team) => acc * team.noVigProbability, 1);
        return { ...combo, winProbability: p * 100 };
      });
    }

    calculatePayouts(combos) {
      // Calculate selection counts for each user combo
      let counts = {};
      combos.forEach(combo => {
        let prob = 1;
        for (let i = 0; i < 3; i++) {
          let pick = +combo.pickString[i];
          const game = this.state.games[i];
          const pickPercents = [
            game.team1.selectionPercentage / 100, 
            game.team2.selectionPercentage / 100
          ];
          prob *= pickPercents[pick];
        }
        counts[combo.pickString] = (this.state.totalEntrants - 1) * prob;
      });

      // Generate all possible outcomes (including pushes)
      const allOutcomes = this.generateAllOutcomes();

      const results = combos.map(combo => {
        let EV = 0;
        let pickProb = 1;
        
        // Calculate pick probability
        for (let i = 0; i < 3; i++) {
          const game = this.state.games[i];
          const pick = +combo.pickString[i];
          const pickPercents = [
            game.team1.selectionPercentage / 100, 
            game.team2.selectionPercentage / 100
          ];
          pickProb *= pickPercents[pick];
        }

        // Calculate EV across all possible outcomes
        allOutcomes.forEach(outcome => {
          // Calculate outcome probability
          let p = 1;
          for (let i = 0; i < 3; i++) {
            const game = this.state.games[i];
            const gameOutcome = outcome[i];
            if (gameOutcome === 'P') {
              p *= game.pushProbability; // Push probability
            } else {
              const probabilities = [game.team1.noVigProbability, game.team2.noVigProbability];
              p *= probabilities[+gameOutcome];
            }
          }

          // Calculate matches for this user pick vs outcome
          const matches = this.calculateMatches(combo.pickString, outcome);
          const isWinner = matches === 3;

          // Count winners for this outcome
          let winners = 0;
          combos.forEach(otherCombo => {
            const otherMatches = this.calculateMatches(otherCombo.pickString, outcome);
            const comboCount = counts[otherCombo.pickString] || 0;
            
            if (otherMatches === 3) {
              winners += comboCount;
            }
          });

          // Add current user if they qualify
          if (isWinner) winners++;

          // Calculate payout
          let gain = -100;
          if (isWinner) {
            const payout = Math.min((this.state.totalEntrants * 100) / winners, this.state.maxPayout);
            gain = payout;
          }

          EV += p * gain;
        });

        return { 
          ...combo, 
          expectedValue: EV - 100, // Subtract the initial 100 cost
          actualWinProbability: this.calculateActualWinProbability(combo.pickString)
        };
      });

      return { combinations: results, payouts: {} };
    }

    calculateActualWinProbability(pickString) {
      const allOutcomes = this.generateAllOutcomes();
      let winProb = 0;

      allOutcomes.forEach(outcome => {
        let p = 1;
        for (let i = 0; i < 3; i++) {
          const game = this.state.games[i];
          const gameOutcome = outcome[i];
          if (gameOutcome === 'P') {
            p *= game.pushProbability;
          } else {
            const probabilities = [game.team1.noVigProbability, game.team2.noVigProbability];
            p *= probabilities[+gameOutcome];
          }
        }

        const matches = this.calculateMatches(pickString, outcome);
        if (matches === 3) {
          winProb += p;
        }
      });

      return winProb * 100;
    }

    calculateAllCombinations() {
      const combos = this.generateCombinations();
      const withSelections = this.calculateSelections(combos);
      const withProb = this.calculateWinProbabilities(withSelections);
      const results = this.calculatePayouts(withProb);

      this.state.results = results;
      this.renderResults();
    }

    formatCombination(combo) {
      return combo.teams.map(t => t.name.replace(/\d+/g, '')).join('');
    }

    renderResults() {
      const list = this.state.results.combinations;
      if (!list.length) return document.getElementById('results-container').style.display = 'none';

      const sorted = [...list].sort((a, b) => {
        let va = a[this.state.sortBy], vb = b[this.state.sortBy];
        if (this.state.sortBy === 'picks') {
          va = this.formatCombination(a);
          vb = this.formatCombination(b);
        }
        return this.state.sortDirection === 'asc' ? (va > vb ? 1 : -1) : (va < vb ? 1 : -1);
      });

      // Calculate average payout for display
      const avgWinners = this.state.totalEntrants / 8; // Rough estimate
      const avgPayout = Math.min((this.state.totalEntrants * 100) / avgWinners, this.state.maxPayout);

      const html = sorted.map(combo => `
        <tr>
          <td>${this.formatCombination(combo)}</td>
          <td>${combo.actualWinProbability.toFixed(2)}%</td>
          <td>${combo.numberOfSelections}</td>
          <td>${Math.round(avgPayout)}</td>
          <td>${Math.round(combo.expectedValue)}</td>
        </tr>
      `).join('');

      const infoNote = this.state.games.some(g => g.spreadType === '0.0') ? 
        `<div class="info-box">
          <p><strong>Win Probabilities Based On:</strong><br>
          No-vig odds are used for calculations to remove bookmakers' edge. Push probabilities are calculated for .0 spreads.<br>
          <strong>Push Rule:</strong> When a push occurs, both L and R picks are considered correct for that game.</p>
        </div>` : 
        `<div class="info-box">
          <p><strong>Win Probabilities Based On:</strong><br>
          No-vig odds are used for calculations to remove bookmakers' edge.</p>
        </div>`;

      const table = `
        <div class="card">
          ${infoNote}
          <h2 class="subheading">All Combinations and Payouts</h2>
          <div class="table-container">
            <table>
              <thead>
                <tr>
                  <th>Picks</th>
                  <th>Win Probability</th>
                  <th>Selections</th>
                  <th>Avg Payout</th>
                  <th>Expected Value</th>
                </tr>
              </thead>
              <tbody>${html}</tbody>
            </table>
          </div>
        </div>
      `;

      const container = document.getElementById('results-container');
      container.style.display = 'block';
      container.innerHTML = table;
    }

    copyResultsToClipboard() {
      const results = this.state.results.combinations;
      if (!results.length) return;

      const str = results.map(c => {
        const pick = this.formatCombination(c);
        return `${pick} - ${c.actualWinProbability.toFixed(2)}% - (${c.expectedValue.toFixed(2)})`;
      }).join('\n');

      navigator.clipboard.writeText(str).then(() => alert("Results copied!"));
    }

    sortTable(column) {
      this.state.sortBy = column;
      this.state.sortDirection = this.state.sortDirection === 'asc' ? 'desc' : 'asc';
      this.renderResults();
    }
  }

  window.app = new PoolCalculator();
});
</script>
</body>
</html>
